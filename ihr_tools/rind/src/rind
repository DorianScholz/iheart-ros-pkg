#!/usr/bin/env python
# Software License Agreement (BSD License)
#
# Copyright (c) 2008, I Heart Engineering
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of I Heart Engineering nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
import gtk
import time
import os
import signal
import subprocess
from threading import Thread
import appindicator
import sys
import glob

import roslib; roslib.load_manifest('rind')
import rosgraph.masterapi

__package_dir = roslib.packages.get_pkg_dir('rind')

class Update(Thread):
    def __init__(self, ind):
        self._ind = ind
        self._exit = False
        self._master = rosgraph.masterapi.Master('/rind')
        self._master_online = 0
        self._roscore_pid = None
        self._roscore_menu_item = None
        self._topics = [] # List of Topics
        self._nodes = [] # List of Topics
        self._pubs = {} # Publishers keyed by topic
        self._subs = {} # Subscribers keyed by topic
        # Connect GTK callbacks
        self.build_menu()
        Thread.__init__(self)

    def check_master(self):
        if not self._master_online and self._master.is_online():
            print 'Master has come online'
            self._master_online = True

            pid_files = glob.glob(os.path.join(os.environ['HOME'], '.ros', 'roscore*.pid'))
            if pid_files and os.access(pid_files[0], os.R_OK):
                pid_file = open(pid_files[0], 'r')
                self._roscore_pid = int(pid_file.readline())
            else:
                self._roscore_pid = None
            print 'ROS Core pid', self._roscore_pid
            # FIXME Figure out how to kill roscore based on the master pid?
            #self._roscore_pid = self._master.getPid()
            
        elif self._master_online and not self._master.is_online():
            print 'Master has gone offline'
            self._master_online = False
            self._topics = []
            self._nodes = []
            self._roscore_pid = None
            self._pubs = {}
            self._subs = {}

    def update_topic_info(self):
        if self._master.is_online():
            topic_pubs, topic_subs, _ = self._master.getSystemState()
            for topic, pubs in topic_pubs:
                self._pubs[topic] = pubs
            for topic, subs in topic_subs:
                self._subs[topic] = subs
            self._topics = sorted(set(self._pubs.keys() + self._subs.keys()))
        else:
            self._topics = []
            self._pubs = {}
            self._subs = {}

    def update_node_info(self):
        # This might be wrong because a node may not be puslishing
        # or subscribing, but this is how rosnode does it
        self._nodes = []
        if self._master.is_online() and len(self._topics) > 0:
            nodes_set = set()
            nodes_set.update(*self._pubs.values())
            nodes_set.update(*self._subs.values())
            self._nodes = sorted(nodes_set)

    def menuitem_quit(self, item):
        print 'Shutting down'
        self.stop()
        # Shutdown here...
        sys.exit(0)

    def menuitem_launchconsole(self, item):
        subprocess.Popen(['rxconsole'], shell=True, stdin=None, stdout=None, stderr=None, cwd=os.environ['HOME'])

    def menuitem_launchrqt(self, item):
        subprocess.Popen(['rosrun rqt_gui rqt_gui'], shell=True, stdin=None, stdout=None, stderr=None, cwd=os.environ['HOME'])

    def menuitem_roscore(self, item):
        if self._master_online:
            if self._roscore_pid is not None:
                print 'Stopping ROS Core'
                os.kill(self._roscore_pid, signal.SIGINT)
                self._master_online = False
            else:
                print 'Error Stopping ROS Core by PID'
        else:
            print 'Starting ROS Core'
            self._roscore_menu_item.set_sensitive(False)
            #subprocess.Popen(['roscore'], shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=os.environ['HOME'])
            subprocess.Popen(['roscore > /dev/null'], shell=True, stdin=None, stdout=None, stderr=None, cwd=os.environ['HOME'])

    def build_menu(self):
        menu = gtk.Menu()
        menu.set_double_buffered(True)

        if self._master_online:
            self._ind.set_icon('rind-panel')
            if self._roscore_pid is not None:
                self._roscore_menu_item = gtk.MenuItem('Shutdown ROS Core')
            else:
                self._roscore_menu_item = gtk.MenuItem('Connected to ROS Master')
                self._roscore_menu_item.set_state(gtk.STATE_INSENSITIVE)
        else:
            self._ind.set_icon('rind-idle')
            self._roscore_menu_item = gtk.MenuItem('Launch ROS Core')
            self._roscore_menu_item.set_sensitive(True)
        self._roscore_menu_item.show()
        self._roscore_menu_item.connect('activate', self.menuitem_roscore)
        menu.append(self._roscore_menu_item)

        if len(self._topics) > 0:
            menu_item = gtk.SeparatorMenuItem()
            menu_item.show()
            menu.append(menu_item)

            menu_item = gtk.MenuItem('Topics')
            menu_item.set_state(gtk.STATE_INSENSITIVE)
            menu_item.show()
            menu.append(menu_item)

            for topic in self._topics:
                menu_item = gtk.MenuItem('  ' + topic.replace('_','__'))
                #menu_item.set_state(gtk.STATE_INSENSITIVE)
                menu_item.show()

                sub_menu = gtk.Menu()

                sub_menu_item = gtk.MenuItem('Publishers')
                sub_menu_item.set_state(gtk.STATE_INSENSITIVE)
                sub_menu_item.show()
                sub_menu.append(sub_menu_item)

                for pub in self._pubs.get(topic, []):
                    sub_menu_item = gtk.MenuItem('  ' + pub.replace('_','__'))
                    sub_menu_item.set_state(gtk.STATE_INSENSITIVE)
                    sub_menu_item.show()
                    sub_menu.append(sub_menu_item)

                sub_menu_item = gtk.MenuItem('Subscribers')
                sub_menu_item.set_state(gtk.STATE_INSENSITIVE)
                sub_menu_item.show()
                sub_menu.append(sub_menu_item)

                for sub in self._subs.get(topic, []):
                    sub_menu_item = gtk.MenuItem('  ' + sub.replace('_','__'), False)
                    sub_menu_item.set_state(gtk.STATE_INSENSITIVE)
                    sub_menu_item.show()
                    sub_menu.append(sub_menu_item)

                sub_menu.show()
                menu_item.set_submenu(sub_menu)
                menu.append(menu_item)

        if self._nodes is not None and len(self._nodes) > 0:
            menu_item = gtk.SeparatorMenuItem()
            menu_item.show()
            menu.append(menu_item)

            menu_item = gtk.MenuItem('Nodes')
            menu_item.set_state(gtk.STATE_INSENSITIVE)
            menu_item.show()
            menu.append(menu_item)

            for node in self._nodes:
                menu_item = gtk.MenuItem('  ' + node.replace('_','__'))
                menu_item.set_state(gtk.STATE_INSENSITIVE)
                menu_item.show()
                menu.append(menu_item)

        menu_item = gtk.SeparatorMenuItem()
        menu_item.show()
        menu.append(menu_item)

        menu_item = gtk.MenuItem('Launch rqt__gui')
        menu_item.show()
        menu_item.connect('activate', self.menuitem_launchrqt)
        menu.append(menu_item)

        menu_item = gtk.MenuItem('Launch rxConsole')
        menu_item.show()
        menu_item.connect('activate', self.menuitem_launchconsole)
        menu.append(menu_item)

        menu_item = gtk.MenuItem('Quit')
        menu_item.show()
        menu_item.connect('activate', self.menuitem_quit)
        menu.append(menu_item)

        self._ind.set_menu(menu)


    def run(self):
        while not self._exit:
            self.check_master()
            self.update_topic_info()
            self.update_node_info()
            gtk.gdk.threads_enter()
            self.build_menu()
            gtk.gdk.threads_leave()
            time.sleep(1)

    def stop(self):
        self._exit = True

if __name__ == '__main__':
    ind = appindicator.Indicator('example-simple-client', 'rind-idle', appindicator.CATEGORY_APPLICATION_STATUS, __package_dir + '/icons')
    ind.set_status(appindicator.STATUS_ACTIVE)
    #ind.set_status(appindicator.STATUS_ATTENTION)
    ind.set_attention_icon('rind-red')
    update = Update(ind)
    update.start()
    gtk.gdk.threads_init()
    try:
        gtk.main()
    except KeyboardInterrupt:
        update.stop()
        sys.exit(0)
