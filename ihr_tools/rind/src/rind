#!/usr/bin/env python
# Software License Agreement (BSD License)
#
# Copyright (c) 2008, I Heart Engineering
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of I Heart Engineering nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
import gtk
import time
import os
import signal
import subprocess
from threading import Thread
import appindicator
import sys
import glob

import roslib; roslib.load_manifest('rind')
import rosgraph.masterapi
import rosnode

__package_dir = roslib.packages.get_pkg_dir('rind')
_has_rxtools = roslib.packages.get_pkg_dir('rxtools', required=False) is not None
_has_rqt_gui = roslib.packages.get_pkg_dir('rqt_gui', required=False) is not None

class IndicatorUpdateThread(Thread):
    def __init__(self, indicator):
        super(IndicatorUpdateThread, self).__init__()
        self._ind = indicator
        self._exit = False
        self._master = rosgraph.masterapi.Master('/rind')
        self._master_online = 0
        self._roscore_pid = None
        self._topics = [] # List of Topics
        self._nodes = [] # List of Topics
        self._publishers = {} # Publishers keyed by topic
        self._subscribers = {} # Subscribers keyed by topic
        self._menu_description = []
        self._launchers = []
        if _has_rqt_gui:
            self._launchers.append({'text': 'rqt_gui', 'activate': self.menuitem_launchrqt})
        if _has_rxtools:
            self._launchers.append({'text': 'rxConsole', 'activate': self.menuitem_launchrxconsole})

    def check_master(self):
        if not self._master_online and self._master.is_online():
            print 'Master has come online'
            self._master_online = True

            try:
                # try to get roscore's pid from the pid of rosmaster 
                self._roscore_pid = int(subprocess.check_output(['ps', '-p', '%d' % self._master.getPid(), '-oppid=']).strip())
            except:
                # try to get roscore's pid from .pid file
                pid_files = glob.glob(os.path.join(os.environ['HOME'], '.ros', 'roscore*.pid'))
                if pid_files and os.access(pid_files[0], os.R_OK):
                    pid_file = open(pid_files[0], 'r')
                    self._roscore_pid = int(pid_file.readline())
                else:
                    self._roscore_pid = None
            
            print 'ROS Core pid', self._roscore_pid
            
        elif self._master_online and not self._master.is_online():
            print 'Master has gone offline'
            self._master_online = False
            self._topics = []
            self._nodes = []
            self._roscore_pid = None
            self._publishers = {}
            self._subscribers = {}

    def update_topic_info(self):
        if self._master.is_online():
            topic_pubs, topic_subs, service_providers = self._master.getSystemState()
            self._publishers = dict(topic_pubs)
            self._subscribers = dict(topic_subs)
            self._service_providers = dict(service_providers)
            self._topics = sorted(set(self._publishers.keys() + self._subscribers.keys()))
        else:
            self._topics = []
            self._publishers = {}
            self._subscribers = {}
            self._service_providers = {}

    def update_node_info(self):
        self._nodes = []
        if self._master.is_online():
            self._nodes = rosnode.get_node_names()

    def menuitem_quit(self, item):
        print 'Shutting down'
        self.stop()
        # Shutdown here...
        sys.exit(0)

    def menuitem_launchrxconsole(self, item):
        subprocess.Popen(['rxconsole'], shell=True, stdin=None, stdout=None, stderr=None, cwd=os.environ['HOME'])

    def menuitem_launchrqt(self, item):
        subprocess.Popen(['rosrun rqt_gui rqt_gui'], shell=True, stdin=None, stdout=None, stderr=None, cwd=os.environ['HOME'])

    def menuitem_roscore(self, item):
        if self._master_online:
            if self._roscore_pid is not None:
                print 'Stopping ROS Core'
                os.kill(self._roscore_pid, signal.SIGINT)
                self._master_online = False
            else:
                print 'Error Stopping ROS Core by PID'
        else:
            print 'Starting ROS Core'
            #subprocess.Popen(['roscore'], shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=os.environ['HOME'])
            subprocess.Popen(['roscore > /dev/null'], shell=True, stdin=None, stdout=None, stderr=None, cwd=os.environ['HOME'])

    def build_menu(self):
        def add_submenu(menu_description, submenu_name, submenu_description, folding_item_count=5, seperator=False):
            if len(submenu_description) == 0:
                return
            if seperator:
                menu_description.append({})
            menu_description.append({'text': submenu_name})
            if len(submenu_description) > folding_item_count:
                menu_description[-1]['submenu_description'] = submenu_description
            else:
                menu_description[-1]['subitem_description'] = submenu_description
                menu_description[-1]['enabled'] = False
            
        menu_description = []
        menu_item_description = {'activate': self.menuitem_roscore}
        if self._master_online:
            self._ind.set_icon('rind-panel')
            if self._roscore_pid is not None:
                menu_item_description['text'] = 'Shutdown ROS Core'
            else:
                menu_item_description['text'] = 'Connected to ROS Master'
                menu_item_description['enabled'] = False
        else:
            self._ind.set_icon('rind-idle')
            menu_item_description['text'] = 'Launch ROS Core'
        menu_description.append(menu_item_description)

        if len(self._topics) > 0:
            topic_menu_descripion = []
            for topic in self._topics:
                submenu_description = []
                
                publisher_menu_description = []
                for publisher in self._publishers.get(topic, []):
                    publisher_menu_description.append({'text': publisher, 'enabled': False})
                add_submenu(submenu_description, 'Publishers', publisher_menu_description)

                subscriber_menu_description = []
                for subscriber in self._subscribers.get(topic, []):
                    subscriber_menu_description.append({'text': subscriber, 'enabled': False})
                add_submenu(submenu_description, 'Subscribers', subscriber_menu_description)

                add_submenu(topic_menu_descripion, topic, submenu_description, folding_item_count=0)
            
            add_submenu(menu_description, 'Topics', topic_menu_descripion, seperator=True)

        if len(self._service_providers) > 0:
            service_menu_descripion = []
            for service in sorted(self._service_providers.keys()):
                submenu_description = []

                provider_description = []
                for provider in self._service_providers.get(service, []):
                    provider_description.append({'text': provider, 'enabled': False})
                add_submenu(submenu_description, 'Providers', provider_description)

                add_submenu(service_menu_descripion, service, submenu_description, folding_item_count=0)

            add_submenu(menu_description, 'Services', service_menu_descripion, seperator=True)

        if len(self._nodes) > 0:
            node_menu_description = []
            for node in self._nodes:
                node_menu_description.append({'text': node, 'enabled': False})

            add_submenu(menu_description, 'Nodes', node_menu_description, seperator=True)

        if self._master_online:
            add_submenu(menu_description, 'Launchers', self._launchers, seperator=True)

        menu_description.append({})
        menu_description.append({'text': 'Quit', 'activate': self.menuitem_quit})

        return menu_description

    def update_menu(self):
        def add_menu_item(menu=None, text=None, enabled=True, activate=None, indentation='', **kwargs):
            if text is None:
                menu_item = gtk.SeparatorMenuItem()
            else:
                menu_item = gtk.MenuItem(indentation + text.replace('_', '__'))
                menu_item.set_sensitive(enabled)
                if activate is not None:
                    menu_item.connect('activate', activate)
            menu_item.show()
            if menu is not None:
                menu.append(menu_item)
            return menu_item
        
        def generate_gtk_menu_items(menu_descripion, indentation=''):
            menu_items = []
            for menu_item_description in menu_descripion:
                menu_item = add_menu_item(indentation=indentation, **menu_item_description)
                menu_items.append(menu_item)
                if menu_item_description.get('submenu_description', None) is not None:
                    menu_item.set_submenu(generate_gtk_menu(menu_item_description['submenu_description']))
                if menu_item_description.get('subitem_description', None) is not None:
                    for sub_item in generate_gtk_menu_items(menu_item_description['subitem_description'], indentation=indentation + '  '):
                        menu_items.append(sub_item)
            return menu_items
        
        def generate_gtk_menu(menu_descripion):
            menu = gtk.Menu()
            menu.set_double_buffered(True)
            for menu_item in generate_gtk_menu_items(menu_descripion):
                menu.append(menu_item)
            return menu

        self._ind.set_menu(generate_gtk_menu(self._menu_description))

    def run(self):
        while not self._exit:
            self.check_master()
            self.update_topic_info()
            self.update_node_info()
            menu_descripion = self.build_menu()
            if str(self._menu_description) != str(menu_descripion):
                self._menu_description = menu_descripion
                gtk.gdk.threads_enter()
                self.update_menu()
                gtk.gdk.threads_leave()
            time.sleep(1)

    def stop(self):
        self._exit = True

if __name__ == '__main__':
    indicator = appindicator.Indicator('ros-indicator', 'rind-idle', appindicator.CATEGORY_APPLICATION_STATUS, __package_dir + '/icons')
    indicator.set_status(appindicator.STATUS_ACTIVE)
    #indicator.set_status(appindicator.STATUS_ATTENTION)
    indicator.set_attention_icon('rind-red')
    indicatorUpdateThread = IndicatorUpdateThread(indicator)
    indicatorUpdateThread.start()
    gtk.gdk.threads_init()
    try:
        gtk.main()
    except KeyboardInterrupt:
        indicatorUpdateThread.stop()
        sys.exit(0)
